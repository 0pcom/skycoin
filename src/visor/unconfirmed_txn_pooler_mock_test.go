// Code generated by mockery v1.0.0
package visor

import (
	"github.com/boltdb/bolt"
	"github.com/stretchr/testify/mock"

	"github.com/skycoin/skycoin/src/cipher"
	"github.com/skycoin/skycoin/src/coin"
)

// UnconfirmedTxnPoolerMock is an autogenerated mock type for the UnconfirmedTxnPooler type
type UnconfirmedTxnPoolerMock struct {
	mock.Mock
}

func NewUnconfirmedTxnPoolerMock() *UnconfirmedTxnPoolerMock {
	return &UnconfirmedTxnPoolerMock{}
}

// ForEach provides a mock function with given fields: tx, f
func (_m *UnconfirmedTxnPoolerMock) ForEach(tx *bolt.Tx, f func(cipher.SHA256, UnconfirmedTxn) error) error {
	ret := _m.Called(tx, f)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, func(cipher.SHA256, UnconfirmedTxn) error) error); ok {
		r0 = rf(tx, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: tx, hash
func (_m *UnconfirmedTxnPoolerMock) Get(tx *bolt.Tx, hash cipher.SHA256) (*UnconfirmedTxn, error) {
	ret := _m.Called(tx, hash)

	var r0 *UnconfirmedTxn
	if rf, ok := ret.Get(0).(func(*bolt.Tx, cipher.SHA256) *UnconfirmedTxn); ok {
		r0 = rf(tx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UnconfirmedTxn)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, cipher.SHA256) error); ok {
		r1 = rf(tx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIncomingOutputs provides a mock function with given fields: tx, bh
func (_m *UnconfirmedTxnPoolerMock) GetIncomingOutputs(tx *bolt.Tx, bh coin.BlockHeader) (coin.UxArray, error) {
	ret := _m.Called(tx, bh)

	var r0 coin.UxArray
	if rf, ok := ret.Get(0).(func(*bolt.Tx, coin.BlockHeader) coin.UxArray); ok {
		r0 = rf(tx, bh)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coin.UxArray)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, coin.BlockHeader) error); ok {
		r1 = rf(tx, bh)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKnown provides a mock function with given fields: tx, txns
func (_m *UnconfirmedTxnPoolerMock) GetKnown(tx *bolt.Tx, txns []cipher.SHA256) (coin.Transactions, error) {
	ret := _m.Called(tx, txns)

	var r0 coin.Transactions
	if rf, ok := ret.Get(0).(func(*bolt.Tx, []cipher.SHA256) coin.Transactions); ok {
		r0 = rf(tx, txns)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coin.Transactions)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, []cipher.SHA256) error); ok {
		r1 = rf(tx, txns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTxHashes provides a mock function with given fields: tx, filter
func (_m *UnconfirmedTxnPoolerMock) GetTxHashes(tx *bolt.Tx, filter func(UnconfirmedTxn) bool) ([]cipher.SHA256, error) {
	ret := _m.Called(tx, filter)

	var r0 []cipher.SHA256
	if rf, ok := ret.Get(0).(func(*bolt.Tx, func(UnconfirmedTxn) bool) []cipher.SHA256); ok {
		r0 = rf(tx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cipher.SHA256)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, func(UnconfirmedTxn) bool) error); ok {
		r1 = rf(tx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTxns provides a mock function with given fields: tx, filter
func (_m *UnconfirmedTxnPoolerMock) GetTxns(tx *bolt.Tx, filter func(UnconfirmedTxn) bool) ([]UnconfirmedTxn, error) {
	ret := _m.Called(tx, filter)

	var r0 []UnconfirmedTxn
	if rf, ok := ret.Get(0).(func(*bolt.Tx, func(UnconfirmedTxn) bool) []UnconfirmedTxn); ok {
		r0 = rf(tx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]UnconfirmedTxn)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, func(UnconfirmedTxn) bool) error); ok {
		r1 = rf(tx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnknown provides a mock function with given fields: tx, txns
func (_m *UnconfirmedTxnPoolerMock) GetUnknown(tx *bolt.Tx, txns []cipher.SHA256) ([]cipher.SHA256, error) {
	ret := _m.Called(tx, txns)

	var r0 []cipher.SHA256
	if rf, ok := ret.Get(0).(func(*bolt.Tx, []cipher.SHA256) []cipher.SHA256); ok {
		r0 = rf(tx, txns)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cipher.SHA256)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, []cipher.SHA256) error); ok {
		r1 = rf(tx, txns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnspentsOfAddr provides a mock function with given fields: tx, addr
func (_m *UnconfirmedTxnPoolerMock) GetUnspentsOfAddr(tx *bolt.Tx, addr cipher.Address) (coin.UxArray, error) {
	ret := _m.Called(tx, addr)

	var r0 coin.UxArray
	if rf, ok := ret.Get(0).(func(*bolt.Tx, cipher.Address) coin.UxArray); ok {
		r0 = rf(tx, addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coin.UxArray)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, cipher.Address) error); ok {
		r1 = rf(tx, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InjectTransaction provides a mock function with given fields: tx, bc, t, maxSize
func (_m *UnconfirmedTxnPoolerMock) InjectTransaction(tx *bolt.Tx, bc Blockchainer, t coin.Transaction, maxSize int) (bool, *ErrTxnViolatesSoftConstraint, error) {
	ret := _m.Called(tx, bc, t, maxSize)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*bolt.Tx, Blockchainer, coin.Transaction, int) bool); ok {
		r0 = rf(tx, bc, t, maxSize)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 *ErrTxnViolatesSoftConstraint
	if rf, ok := ret.Get(1).(func(*bolt.Tx, Blockchainer, coin.Transaction, int) *ErrTxnViolatesSoftConstraint); ok {
		r1 = rf(tx, bc, t, maxSize)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ErrTxnViolatesSoftConstraint)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*bolt.Tx, Blockchainer, coin.Transaction, int) error); ok {
		r2 = rf(tx, bc, t, maxSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Len provides a mock function with given fields: tx
func (_m *UnconfirmedTxnPoolerMock) Len(tx *bolt.Tx) (uint64, error) {
	ret := _m.Called(tx)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(*bolt.Tx) uint64); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RawTxns provides a mock function with given fields: tx
func (_m *UnconfirmedTxnPoolerMock) RawTxns(tx *bolt.Tx) (coin.Transactions, error) {
	ret := _m.Called(tx)

	var r0 coin.Transactions
	if rf, ok := ret.Get(0).(func(*bolt.Tx) coin.Transactions); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coin.Transactions)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecvOfAddresses provides a mock function with given fields: tx, bh, addrs
func (_m *UnconfirmedTxnPoolerMock) RecvOfAddresses(tx *bolt.Tx, bh coin.BlockHeader, addrs []cipher.Address) (coin.AddressUxOuts, error) {
	ret := _m.Called(tx, bh, addrs)

	var r0 coin.AddressUxOuts
	if rf, ok := ret.Get(0).(func(*bolt.Tx, coin.BlockHeader, []cipher.Address) coin.AddressUxOuts); ok {
		r0 = rf(tx, bh, addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coin.AddressUxOuts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, coin.BlockHeader, []cipher.Address) error); ok {
		r1 = rf(tx, bh, addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Refresh provides a mock function with given fields: tx, bc, maxBlockSize
func (_m *UnconfirmedTxnPoolerMock) Refresh(tx *bolt.Tx, bc Blockchainer, maxBlockSize int) ([]cipher.SHA256, error) {
	ret := _m.Called(tx, bc, maxBlockSize)

	var r0 []cipher.SHA256
	if rf, ok := ret.Get(0).(func(*bolt.Tx, Blockchainer, int) []cipher.SHA256); ok {
		r0 = rf(tx, bc, maxBlockSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cipher.SHA256)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, Blockchainer, int) error); ok {
		r1 = rf(tx, bc, maxBlockSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveInvalid provides a mock function with given fields: tx, bc
func (_m *UnconfirmedTxnPoolerMock) RemoveInvalid(tx *bolt.Tx, bc Blockchainer) ([]cipher.SHA256, error) {
	ret := _m.Called(tx, bc)

	var r0 []cipher.SHA256
	if rf, ok := ret.Get(0).(func(*bolt.Tx, Blockchainer) []cipher.SHA256); ok {
		r0 = rf(tx, bc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cipher.SHA256)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, Blockchainer) error); ok {
		r1 = rf(tx, bc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTransactions provides a mock function with given fields: tx, txns
func (_m *UnconfirmedTxnPoolerMock) RemoveTransactions(tx *bolt.Tx, txns []cipher.SHA256) error {
	ret := _m.Called(tx, txns)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, []cipher.SHA256) error); ok {
		r0 = rf(tx, txns)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetTxnsAnnounced provides a mock function with given fields: tx, hashes, t
func (_m *UnconfirmedTxnPoolerMock) SetTxnsAnnounced(tx *bolt.Tx, hashes []cipher.SHA256, t int64) error {
	ret := _m.Called(tx, hashes, t)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, []cipher.SHA256, int64) error); ok {
		r0 = rf(tx, hashes, t)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
