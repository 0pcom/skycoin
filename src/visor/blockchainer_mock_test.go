// Code generated by mockery v1.0.0
package visor

import (
	"github.com/boltdb/bolt"
	"github.com/stretchr/testify/mock"

	"github.com/skycoin/skycoin/src/cipher"
	"github.com/skycoin/skycoin/src/coin"
	"github.com/skycoin/skycoin/src/visor/blockdb"
)

// BlockchainerMock is an autogenerated mock type for the Blockchainer type
type BlockchainerMock struct {
	mock.Mock
}

func NewBlockchainerMock() *BlockchainerMock {
	return &BlockchainerMock{}
}

// BindListener provides a mock function with given fields: bl
func (_m *BlockchainerMock) BindListener(bl BlockListener) {
	_m.Called(bl)
}

// ExecuteBlock provides a mock function with given fields: tx, sb
func (_m *BlockchainerMock) ExecuteBlock(tx *bolt.Tx, sb *coin.SignedBlock) error {
	ret := _m.Called(tx, sb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, *coin.SignedBlock) error); ok {
		r0 = rf(tx, sb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBlocks provides a mock function with given fields: tx, start, end
func (_m *BlockchainerMock) GetBlocks(tx *bolt.Tx, start uint64, end uint64) ([]coin.SignedBlock, error) {
	ret := _m.Called(tx, start, end)

	var r0 []coin.SignedBlock
	if rf, ok := ret.Get(0).(func(*bolt.Tx, uint64, uint64) []coin.SignedBlock); ok {
		r0 = rf(tx, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]coin.SignedBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, uint64, uint64) error); ok {
		r1 = rf(tx, start, end)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGenesisBlock provides a mock function with given fields: tx
func (_m *BlockchainerMock) GetGenesisBlock(tx *bolt.Tx) (*coin.SignedBlock, error) {
	ret := _m.Called(tx)

	var r0 *coin.SignedBlock
	if rf, ok := ret.Get(0).(func(*bolt.Tx) *coin.SignedBlock); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coin.SignedBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastBlocks provides a mock function with given fields: tx, n
func (_m *BlockchainerMock) GetLastBlocks(tx *bolt.Tx, n uint64) ([]coin.SignedBlock, error) {
	ret := _m.Called(tx, n)

	var r0 []coin.SignedBlock
	if rf, ok := ret.Get(0).(func(*bolt.Tx, uint64) []coin.SignedBlock); ok {
		r0 = rf(tx, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]coin.SignedBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, uint64) error); ok {
		r1 = rf(tx, n)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSignedBlockByHash provides a mock function with given fields: tx, hash
func (_m *BlockchainerMock) GetSignedBlockByHash(tx *bolt.Tx, hash cipher.SHA256) (*coin.SignedBlock, error) {
	ret := _m.Called(tx, hash)

	var r0 *coin.SignedBlock
	if rf, ok := ret.Get(0).(func(*bolt.Tx, cipher.SHA256) *coin.SignedBlock); ok {
		r0 = rf(tx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coin.SignedBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, cipher.SHA256) error); ok {
		r1 = rf(tx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSignedBlockBySeq provides a mock function with given fields: tx, seq
func (_m *BlockchainerMock) GetSignedBlockBySeq(tx *bolt.Tx, seq uint64) (*coin.SignedBlock, error) {
	ret := _m.Called(tx, seq)

	var r0 *coin.SignedBlock
	if rf, ok := ret.Get(0).(func(*bolt.Tx, uint64) *coin.SignedBlock); ok {
		r0 = rf(tx, seq)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coin.SignedBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, uint64) error); ok {
		r1 = rf(tx, seq)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Head provides a mock function with given fields: tx
func (_m *BlockchainerMock) Head(tx *bolt.Tx) (*coin.SignedBlock, error) {
	ret := _m.Called(tx)

	var r0 *coin.SignedBlock
	if rf, ok := ret.Get(0).(func(*bolt.Tx) *coin.SignedBlock); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coin.SignedBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HeadSeq provides a mock function with given fields: tx
func (_m *BlockchainerMock) HeadSeq(tx *bolt.Tx) (uint64, bool, error) {
	ret := _m.Called(tx)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(*bolt.Tx) uint64); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(*bolt.Tx) bool); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*bolt.Tx) error); ok {
		r2 = rf(tx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Len provides a mock function with given fields: tx
func (_m *BlockchainerMock) Len(tx *bolt.Tx) (uint64, error) {
	ret := _m.Called(tx)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(*bolt.Tx) uint64); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBlock provides a mock function with given fields: tx, txns, currentTime
func (_m *BlockchainerMock) NewBlock(tx *bolt.Tx, txns coin.Transactions, currentTime uint64) (*coin.Block, error) {
	ret := _m.Called(tx, txns, currentTime)

	var r0 *coin.Block
	if rf, ok := ret.Get(0).(func(*bolt.Tx, coin.Transactions, uint64) *coin.Block); ok {
		r0 = rf(tx, txns, currentTime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coin.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx, coin.Transactions, uint64) error); ok {
		r1 = rf(tx, txns, currentTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Notify provides a mock function with given fields: b
func (_m *BlockchainerMock) Notify(b coin.Block) {
	_m.Called(b)
}

// Time provides a mock function with given fields: tx
func (_m *BlockchainerMock) Time(tx *bolt.Tx) (uint64, error) {
	ret := _m.Called(tx)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(*bolt.Tx) uint64); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bolt.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransactionFee provides a mock function with given fields: tx, hours
func (_m *BlockchainerMock) TransactionFee(tx *bolt.Tx, hours uint64) coin.FeeCalculator {
	ret := _m.Called(tx, hours)

	var r0 coin.FeeCalculator
	if rf, ok := ret.Get(0).(func(*bolt.Tx, uint64) coin.FeeCalculator); ok {
		r0 = rf(tx, hours)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coin.FeeCalculator)
		}
	}

	return r0
}

// Unspent provides a mock function with given fields:
func (_m *BlockchainerMock) Unspent() blockdb.UnspentPool {
	ret := _m.Called()

	var r0 blockdb.UnspentPool
	if rf, ok := ret.Get(0).(func() blockdb.UnspentPool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(blockdb.UnspentPool)
		}
	}

	return r0
}

// VerifyBlockTxnConstraints provides a mock function with given fields: tx, txn
func (_m *BlockchainerMock) VerifyBlockTxnConstraints(tx *bolt.Tx, txn coin.Transaction) error {
	ret := _m.Called(tx, txn)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, coin.Transaction) error); ok {
		r0 = rf(tx, txn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifySingleTxnAllConstraints provides a mock function with given fields: tx, txn, maxSize
func (_m *BlockchainerMock) VerifySingleTxnAllConstraints(tx *bolt.Tx, txn coin.Transaction, maxSize int) error {
	ret := _m.Called(tx, txn, maxSize)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, coin.Transaction, int) error); ok {
		r0 = rf(tx, txn, maxSize)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifySingleTxnHardConstraints provides a mock function with given fields: tx, txn
func (_m *BlockchainerMock) VerifySingleTxnHardConstraints(tx *bolt.Tx, txn coin.Transaction) error {
	ret := _m.Called(tx, txn)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bolt.Tx, coin.Transaction) error); ok {
		r0 = rf(tx, txn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
